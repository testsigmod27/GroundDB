// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "c.h"
#include "postgres.h"
#include <cstring>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <stdlib.h>

#include "DataPageAccess.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/concurrency/ThreadManager.h>
#include "storage/fd.h"
#include "commands/tablespace.h"
#include "common/controldata_utils.h"
#include "catalog/pg_control.h"
#include "storage/rpcserver.h"
#include "storage/bufmgr.h"
#include <sys/stat.h>
#include "storage/copydir.h"
#include "storage/md.h"
#include "catalog/catalog.h"
#include "utils/relcache.h"
#include "utils/palloc.h"
#include "storage/smgr.h"
#include "utils/rel.h"
#include "tcop/storage_server.h"
#include "access/logindex_hashmap.h"
#include "access/wakeup_latch.h"
#include "replication/walreceiver.h"
#include "storage/kv_interface.h"
#include "storage/buf_internals.h"
#include "access/xlog.h"
#include "pgstat.h"
#include "storage/rel_cache.h"
#include "access/xlog_internal.h"

#define NeonListenPort 15432

#define NeonApiPort 64000

#define LsnLatency (128)

extern HashMap pageVersionHashMap;

extern int reachXlogTempEnd;
extern int XLOGbuffers;

extern XLogRecPtr *RpcXlblocks;
extern char *RpcXLogPages;
extern pthread_rwlock_t *RpcXLogPagesLocks;

extern uint64_t RpcXLogFlushedLsn;

int neon_socket;
int neon_api_socket[NeonApiSocketNum];
unsigned long long NeonStartupLSN;
unsigned long long AuroraStartupLSN;
int NeonCachedUp = 0;
unsigned long long NeonFlushedLSN = -1;
extern pthread_mutex_t *NeonAccessLock;

struct{
        bool initialized;
        uint64_t requestLsn; uint64_t notModifiedSinceLsn; uint32_t spcId; uint32_t dbId; uint32_t relId; uint8_t forkNum;
}neon_api_arguments_for_heartbeat;


// #define DEBUG_TIMING 1
// #define INFO_FUNC_START
// #define INFO_FUNC_START2
// #define ENABLE_DEBUG_INFO
// #define ENABLE_DEBUG_INFO2

// #define ENABLE_FUNCTION_TIMING

#ifdef ENABLE_FUNCTION_TIMING
#include <sys/time.h>
#include <pthread.h>
#include <cstdlib>

class FunctionTiming
{
public:
        struct timeval start;
        struct timeval reTiming;
        char *funcname;
        FunctionTiming(char *paraFuncName)
        {
                funcname = paraFuncName;
                gettimeofday(&start, NULL);
                gettimeofday(&reTiming, NULL);
        }

        void RecordTime(int lineNum)
        {
                struct timeval tempTiming;
                gettimeofday(&tempTiming, NULL);
                printf("%s%d function timeing = %ld us\n", funcname, lineNum,
                       (tempTiming.tv_sec * 1000000 + tempTiming.tv_usec) - (reTiming.tv_sec * 1000000 + reTiming.tv_usec));
                fflush(stdout);

                gettimeofday(&reTiming, NULL);
        }

        inline ~FunctionTiming()
        {
                struct timeval end;
                gettimeofday(&end, NULL);
                printf("%s function timeing = %ld us\n", funcname,
                       (end.tv_sec * 1000000 + end.tv_usec) - (start.tv_sec * 1000000 + start.tv_usec));
                fflush(stdout);
        }
};
#endif

#ifdef DEBUG_TIMING

#include <sys/time.h>
#include <pthread.h>
#include <cstdlib>

int initialized = 0;
struct timeval output_timing;

pthread_mutex_t timing_mutex = PTHREAD_MUTEX_INITIALIZER;
long readBufferCommon[36];
long readBufferCount[36];

long nblocksTime[16];
long nblocksCount[16];

long existsTime[16];
long existsCount[16];

void PrintTimingResult()
{
        struct timeval now;

        if (!initialized)
        {
                gettimeofday(&output_timing, NULL);
                initialized = 1;

                memset(readBufferCount, 0, 16 * sizeof(readBufferCount[0]));
                memset(readBufferCommon, 0, 16 * sizeof(readBufferCommon[0]));

                memset(nblocksCount, 0, 16 * sizeof(nblocksCount[0]));
                memset(nblocksTime, 0, 16 * sizeof(nblocksTime[0]));

                memset(existsCount, 0, 16 * sizeof(existsCount[0]));
                memset(existsTime, 0, 16 * sizeof(existsTime[0]));
        }

        gettimeofday(&now, NULL);

        if (now.tv_sec - output_timing.tv_sec >= 1)
        {
                for (int i = 0; i < 35; i++)
                {
                        if (readBufferCount[i] == 0)
                                continue;
                        printf("readBufferCommon_%d = %ld\n", i, readBufferCommon[i] / readBufferCount[i]);
                        printf("total_readBufferCommon_%d = %ld, count = %ld\n", i, readBufferCommon[i], readBufferCount[i]);
                        fflush(stdout);
                }

                for (int i = 0; i < 9; i++)
                {
                        if (nblocksCount[i] == 0)
                                continue;
                        printf("nblocks_%d = %ld\n", i, nblocksTime[i] / nblocksCount[i]);
                        printf("nblocks_%d = %ld, count = %ld\n", i, nblocksTime[i], nblocksCount[i]);
                        fflush(stdout);
                }

                for (int i = 0; i < 9; i++)
                {
                        if (existsCount[i] == 0)
                                continue;
                        printf("exists_%d = %ld\n", i, existsTime[i] / existsCount[i]);
                        printf("exists_%d = %ld, count = %ld\n", i, existsTime[i], existsCount[i]);
                        fflush(stdout);
                }

                output_timing = now;
        }
}

#define START_TIMING(start_p)                \
        do                                   \
        {                                    \
                gettimeofday(start_p, NULL); \
        } while (0);

#define RECORD_TIMING(start_p, end_p, global_timing, global_count)                                                                        \
        do                                                                                                                                \
        {                                                                                                                                 \
                gettimeofday(end_p, NULL);                                                                                                \
                pthread_mutex_lock(&timing_mutex);                                                                                        \
                (*global_timing) += ((*end_p.tv_sec * 1000000 + *end_p.tv_usec) - (*start_p.tv_sec * 1000000 + *start_p.tv_usec)) / 1000; \
                (*global_count)++;                                                                                                        \
                pthread_mutex_unlock(&timing_mutex);                                                                                      \
                PrintTimingResult();                                                                                                      \
                gettimeofday(start_p, NULL);                                                                                              \
        } while (0);

#endif


struct XLogMsgData
{
        uint64 walStart;
        uint64 walEnd;
        int64 timeStamp;
        uint64 dataSize;
        const char *xlogBody;
};

struct GetPageData
{
        uint64_t requestLsn;
        uint64_t notModifiedSinceLsn;

        uint32_t spcId;
        uint32_t dbId;
        uint32_t relId;

        uint8_t forkNum;
        uint32_t blockNum;
};

struct RelExistsData
{
        uint64_t requestLsn;
        uint64_t notModifiedSinceLsn;

        uint32_t spcId;
        uint32_t dbId;
        uint32_t relId;

        uint8_t forkNum;
};

struct NBlocksData
{
        uint64_t requestLsn;
        uint64_t notModifiedSinceLsn;

        uint32_t spcId;
        uint32_t dbId;
        uint32_t relId;

        uint8_t forkNum;
};

typedef void (*body_writer)(uint8_t **buf, void *context);

void write_body(uint8_t **buf, body_writer writer, void *context)
{
        size_t base = 0; // Current position in the buffer

        // Reserve 4 bytes for the length prefix
        uint8_t *length_ptr = *buf;
        *buf += 4;

        // Call the provided function to write the message body
        writer(buf, context);

        // Calculate the size of the message body
        // int32_t size = (*buf - *buf) - base;
        int32_t size = (*buf - length_ptr);
        if (size > (1 << 31) - 1)
        {
                fprintf(stderr, "message too big to transmit\n");
                exit(EXIT_FAILURE);
        }

        // Write the size as a 4-byte big-endian integer at the start of the reserved space
        size = htonl(size);
        memcpy(length_ptr, &size, sizeof(size));
}

void write_cstr(const char *s, uint8_t **buf)
{
        size_t len = strlen(s);
        memcpy(*buf, s, len);
        *buf += len;
        *(*buf)++ = '\0'; // Null-terminate the string
}

uint64_t htonll(uint64_t value)
{
        if (htonl(1) != 1)
        {
                return ((uint64_t)htonl(value & 0xFFFFFFFF) << 32) | htonl(value >> 32);
        }
        else
        {
                return value;
        }
}

void xlog_msg_writer(uint8_t **buf, void *context)
{
        // write a flag 'w' into buf

        // printf("%s %d\n", __func__, __LINE__);
        // fflush(stdout);

        *(*buf)++ = 'w';

        struct XLogMsgData *data = (struct XLogMsgData *)context;
        uint64_t walStart = data->walStart;
        uint64_t walEnd = data->walEnd;
        int64_t timeStamp = data->timeStamp;
        uint64_t dataSize = data->dataSize;
        const char *xlogBody = data->xlogBody;

        // printf("%s %d\n", __func__, __LINE__);
        // fflush(stdout);

        walStart = htonll(walStart);
        walEnd = htonll(walEnd);
        timeStamp = htonll(timeStamp);

        memcpy(*buf, &walStart, sizeof(walStart));
        *buf += sizeof(walStart);
        memcpy(*buf, &walEnd, sizeof(walEnd));
        *buf += sizeof(walEnd);
        memcpy(*buf, &timeStamp, sizeof(timeStamp));
        *buf += sizeof(timeStamp);

        // printf("%s %d, dataSize = %lu, startLSN = %lu, startLSN_network = %lu, sizeof(walStart) =%lu\n", __func__, __LINE__, dataSize, data->walStart, walStart, sizeof(walStart)); fflush(stdout);

        memcpy(*buf, xlogBody, dataSize);
        *buf += dataSize;

        // printf("%s %d\n", __func__, __LINE__);
        // fflush(stdout);
}

void rel_exists_msg_writer(uint8_t **buf, void *context) {
        struct RelExistsData *data = (struct RelExistsData *)context;

        char msgTag = 0;
        memcpy(*buf, &msgTag, sizeof(msgTag));
        *buf += sizeof(msgTag);

        uint64_t requestLsn = htonll(data->requestLsn);
        memcpy(*buf, &requestLsn, sizeof(requestLsn));
        *buf += sizeof(requestLsn);

        uint64_t notModifiedSinceLsn = htonll(data->notModifiedSinceLsn);
        memcpy(*buf, &notModifiedSinceLsn, sizeof(notModifiedSinceLsn));
        *buf += sizeof(notModifiedSinceLsn);

        uint32_t spcId = htonl(data->spcId);
        memcpy(*buf, &spcId, sizeof(spcId));
        *buf += sizeof(spcId);

        uint32_t dbId = htonl(data->dbId);
        memcpy(*buf, &dbId, sizeof(dbId));
        *buf += sizeof(dbId);

        uint32_t relId = htonl(data->relId);
        memcpy(*buf, &relId, sizeof(relId));
        *buf += sizeof(relId);

        uint8_t forkNum = data->forkNum;
        memcpy(*buf, &forkNum, sizeof(forkNum));
        *buf += sizeof(forkNum);
}

void nblocks_msg_writer(uint8_t **buf, void *context) {
        struct NBlocksData *data = (struct NBlocksData *)context;

        char msgTag = 1;
        memcpy(*buf, &msgTag, sizeof(msgTag));
        *buf += sizeof(msgTag);

        uint64_t requestLsn = htonll(data->requestLsn);
        memcpy(*buf, &requestLsn, sizeof(requestLsn));
        *buf += sizeof(requestLsn);

        uint64_t notModifiedSinceLsn = htonll(data->notModifiedSinceLsn);
        memcpy(*buf, &notModifiedSinceLsn, sizeof(notModifiedSinceLsn));
        *buf += sizeof(notModifiedSinceLsn);

        uint32_t spcId = htonl(data->spcId);
        memcpy(*buf, &spcId, sizeof(spcId));
        *buf += sizeof(spcId);

        uint32_t dbId = htonl(data->dbId);
        memcpy(*buf, &dbId, sizeof(dbId));
        *buf += sizeof(dbId);

        uint32_t relId = htonl(data->relId);
        memcpy(*buf, &relId, sizeof(relId));
        *buf += sizeof(relId);

        uint8_t forkNum = data->forkNum;
        memcpy(*buf, &forkNum, sizeof(forkNum));
        *buf += sizeof(forkNum);
}


void get_page_msg_writer(uint8_t **buf, void *context) {
        struct GetPageData *data = (struct GetPageData *)context;

        char msgTag = 2;
        memcpy(*buf, &msgTag, sizeof(msgTag));
        *buf += sizeof(msgTag);

        uint64_t requestLsn = htonll(data->requestLsn);
        memcpy(*buf, &requestLsn, sizeof(requestLsn));
        *buf += sizeof(requestLsn);

        uint64_t notModifiedSinceLsn = htonll(data->notModifiedSinceLsn);
        memcpy(*buf, &notModifiedSinceLsn, sizeof(notModifiedSinceLsn));
        *buf += sizeof(notModifiedSinceLsn);

        uint32_t spcId = htonl(data->spcId);
        memcpy(*buf, &spcId, sizeof(spcId));
        *buf += sizeof(spcId);

        uint32_t dbId = htonl(data->dbId);
        memcpy(*buf, &dbId, sizeof(dbId));
        *buf += sizeof(dbId);

        uint32_t relId = htonl(data->relId);
        memcpy(*buf, &relId, sizeof(relId));
        *buf += sizeof(relId);

        uint8_t forkNum = data->forkNum;
        memcpy(*buf, &forkNum, sizeof(forkNum));
        *buf += sizeof(forkNum);

        uint32_t blockNum = htonl(data->blockNum);
        memcpy(*buf, &blockNum, sizeof(blockNum));
        *buf += sizeof(blockNum);
}

void pageserver_query_init_writer(uint8_t **buf, void *context)
{
        const char **name_value = (const char **)context;
        const char* tenantId = name_value[0];
        const char* timelineId = name_value[1];

        // The msg is "pagestream_v2 $tenantId $timelineId"
        // Write it to *buf
        write_cstr("pagestream_v2", buf);
        (*buf)--; // delete the '\0' which added by write_cstr

        write_cstr(" ", buf);
        (*buf)--;

        write_cstr(tenantId, buf);
        (*buf)--;

        write_cstr(" ", buf);
        (*buf)--;

        write_cstr(timelineId, buf);
}

void authentication_ok_writer(uint8_t **buf, void *context)
{
        int32_t success = 0;
        success = htonl(success);
        memcpy(*buf, &success, sizeof(success));
        *buf += sizeof(success);
}

void copy_both_response_writer(uint8_t **buf, void *context)
{
        u_int8_t value1 = 0;
        int16_t value2 = 0;

        value1 = htons(value1);
        value2 = htons(value2);

        memcpy(*buf, &value1, sizeof(value1));
        memcpy(*buf + sizeof(value1), &value2, sizeof(value2));

        *buf += sizeof(value1) + sizeof(value2);
}

void parameter_status_writer(uint8_t **buf, void *context)
{
        const char **name_value = (const char **)context;
        write_cstr(name_value[0], buf);
        write_cstr(name_value[1], buf);
}

void ready_for_query_writer(uint8_t **buf, void *context)
{
        *(*buf)++ = 'I';
}

void prepare_pageserver_query_init(uint8_t **buffer, const char *tenantId, const char *timelineId)
{
        const char *context[2] = {tenantId, timelineId};
        **buffer = 'Q'; // Write the first type 'Q'
        *buffer += 1;

        write_body(buffer, pageserver_query_init_writer, context);
        // printf("Prepared PageServerQueryInit message.\n");
}

void prepare_rel_exists_msg(uint8_t **buffer, uint64_t requestLsn, uint64_t notModifiedSinceLsn, uint32_t spcId, uint32_t dbId, uint32_t relId, uint8_t forkNum)
{
        struct RelExistsData data = {requestLsn, notModifiedSinceLsn, spcId, dbId, relId, forkNum};
        **buffer = 'd'; // Write the first type 'd'
        *buffer += 1;

        write_body(buffer, rel_exists_msg_writer, &data);
        // printf("Prepared RelExists message.\n");
}

void prepare_nblocks_msg(uint8_t **buffer, uint64_t requestLsn, uint64_t notModifiedSinceLsn, uint32_t spcId, uint32_t dbId, uint32_t relId, uint8_t forkNum)
{
        struct NBlocksData data = {requestLsn, notModifiedSinceLsn, spcId, dbId, relId, forkNum};
        **buffer = 'd'; // Write the first type 'd'
        *buffer += 1;

        write_body(buffer, nblocks_msg_writer, &data);
        // printf("Prepared NBlocks message.\n");
}

void prepare_get_page_query(uint8_t **buffer, uint64_t requestLsn, uint64_t notModifiedSinceLsn, uint32_t spcId, uint32_t dbId, uint32_t relId, uint8_t forkNum, uint32_t blockNum)
{
        struct GetPageData data = {requestLsn, notModifiedSinceLsn, spcId, dbId, relId, forkNum, blockNum};
        **buffer = 'd'; // Write the first type 'd'
        *buffer += 1;

        write_body(buffer, get_page_msg_writer, &data);
        // printf("Prepared GetPage message.\n");
}

void prepare_xlog_msg(uint8_t **buffer, uint64_t walStart, uint64_t walEnd, int64_t timeStamp, uint64_t dataSize, const char *xlogBody)
{
        struct XLogMsgData data = {walStart, walEnd, timeStamp, dataSize, xlogBody};
        **buffer = 'd'; // Write the first type 'd'
        *buffer += 1;

        // printf("%s %d\n", __func__, __LINE__);
        // fflush(stdout);

        write_body(buffer, xlog_msg_writer, &data);
        // printf("Prepared XLog message.\n");
}

void prepare_authentication_ok(uint8_t **buffer)
{
        **buffer = 'R'; // Write the first type 'R'
        *buffer += 1;
        // *(*buffer)++ = 'R';  // Message type identifier for AuthenticationOk
        write_body(buffer, authentication_ok_writer, NULL);
        // printf("Prepared AuthenticationOk message.\n");
}

void prepare_copy_both_response(uint8_t **buffer)
{
        **buffer = 'W';
        *buffer += 1;
        write_body(buffer, copy_both_response_writer, NULL);
        // printf("Prepared CopyBothResponse message.\n");
}

void prepare_parameter_status(uint8_t **buffer, const char *name, const char *value)
{
        const char *context[2] = {name, value};
        // *(*buffer)++ = 'S';  // Message type identifier for ParameterStatus
        **buffer = 'S';
        *buffer += 1;
        write_body(buffer, parameter_status_writer, context);
        // printf("Prepared ParameterStatus (%s: %s) message.\n", name, value);
}

void prepare_ready_for_query(uint8_t **buffer)
{
        *(*buffer)++ = 'Z'; // Message type identifier for ReadyForQuery
        write_body(buffer, ready_for_query_writer, NULL);
        // printf("Prepared ReadyForQuery message.\n");
}

int establish_socket(int port)
{
    // Create a socket object
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == -1) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }

    // Define the server address and port
    struct sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(port);

    // Convert IPv4 and IPv6 addresses from text to binary form
    if (inet_pton(AF_INET, "127.0.0.1", &server_address.sin_addr) <= 0) {
        perror("Invalid address/Address not supported");
        close(sock);
        exit(EXIT_FAILURE);
    }

    // Connect to the server
    if (connect(sock, (struct sockaddr *)&server_address, sizeof(server_address)) < 0) {
        perror("Connection failed");
        close(sock);
        exit(EXIT_FAILURE);
    }

    return sock;
}

int init_neon_api_socket(int port, char* tenantId, char* timelineId) {
        int sock = establish_socket(port);
        // printf("Connected to the Neon API server on port %d\n", port);

        uint8_t *buffer = (uint8_t *)malloc(8192); 
        uint8_t *buffer_ptr = buffer;
        prepare_pageserver_query_init(&buffer, tenantId, timelineId);

        printf("Prepared PageServerQueryInit message = %s\n", buffer_ptr);
        fflush(stdout);

        // Send the message to the server
        send(sock, buffer_ptr, buffer - buffer_ptr, 0);

        free(buffer_ptr);

        // Read the response from the server
        uint8_t response[8192];
        int bytes_received = recv(sock, response, sizeof(response), 0);
        if (bytes_received < 0) {
            perror("Failed to receive data from the Neon API server");
            close(sock);
            exit(EXIT_FAILURE);
        }

        // printf("%s %d, received %d bytes from neon's PageServerQueryInit API\n", __func__, __LINE__, bytes_received);
        // fflush(stdout);

        return sock;
}

int8_t relexists_from_neon_api(uint64_t requestLsn, uint64_t notModifiedSinceLsn, uint32_t spcId, uint32_t dbId, uint32_t relId, uint8_t forkNum) {
        neon_api_arguments_for_heartbeat = {true, requestLsn, notModifiedSinceLsn, spcId, dbId, relId, forkNum};
        requestLsn = requestLsn - LsnLatency;
        notModifiedSinceLsn = notModifiedSinceLsn - LsnLatency;

        int tid = gettid();
        int socket_select = tid%NeonApiSocketNum;
        int gotLock = 0;
        for(int i = 0; i < NeonApiSocketNum; i++) {
                if(pthread_mutex_trylock( &(NeonAccessLock[ (socket_select+i)%NeonApiSocketNum ]) ) == 0) { // Lock successfully
                        gotLock = 1;
                        socket_select = (socket_select+i) % NeonApiSocketNum;
                        break;
                }
        }

        // if we didn't get lock with trylock(), then use block wait lock
        if(gotLock == 0) {
                pthread_mutex_lock(&(NeonAccessLock[socket_select]));
        }
        int sock = neon_api_socket[socket_select];


        uint8_t *buffer = (uint8_t *)malloc(8192);
        uint8_t *buffer_ptr = buffer;
        prepare_rel_exists_msg(&buffer_ptr, requestLsn, notModifiedSinceLsn, spcId, dbId, relId, forkNum);

        // Send the message to the server
        send(sock, buffer, buffer_ptr - buffer, 0);

        free(buffer);

        // Receive the response from the server
        uint8_t response_orig[8192];
        uint8_t *response = response_orig;
        int bytes_received = recv(sock, response_orig, sizeof(response_orig), 0);
        if (bytes_received < 0) {
            perror("Failed to receive data from the Neon API server");
            close(sock);
            exit(EXIT_FAILURE);
        }
        // printf("%s %d, received %d bytes from neon's RelExists API\n", __func__, __LINE__, bytes_received);
        pthread_mutex_unlock(&(NeonAccessLock[socket_select]));

        // The first byte of the response is the Copy-both message type
        Assert(response[0] == 'd');
        // printf("response type: %c\n", response[0]);
        response += 1;

        // Then following a u32 value to indicate the value length, which should be 8191
        uint32_t value_length = ntohl(*(uint32_t *)(response));
        // printf("remaining value length: %u\n", value_length);
        response += 4;
        if(value_length != 6) {
            printf("value_length != 6, content = %s\n", response);
            return -1;
        }

        // The next 1 byte is the RelExists tag, which should be 'd'
        Assert(response[0] == 100);
        // printf("RelExists tag: %d\n", response[0]);
        response += 1;

        // The next 1 byte is the result, which should be 0 or 1
        uint8_t result = response[0];
        // printf("RelExists result: %u\n", result);

        return result;
}

uint32_t nblocks_from_neon_api(uint64_t requestLsn, uint64_t notModifiedSinceLsn, uint32_t spcId, uint32_t dbId, uint32_t relId, uint8_t forkNum) {
        requestLsn = requestLsn - LsnLatency;
        notModifiedSinceLsn = notModifiedSinceLsn - LsnLatency;

        int tid = gettid();
        int socket_select = tid%NeonApiSocketNum;
        int gotLock = 0;
        for(int i = 0; i < NeonApiSocketNum; i++) {
                if(pthread_mutex_trylock( &(NeonAccessLock[ (socket_select+i)%NeonApiSocketNum ]) ) == 0) { // Lock successfully
                        gotLock = 1;
                        socket_select = (socket_select+i) % NeonApiSocketNum;
                        break;
                }
        }

        // if we didn't get lock with trylock(), then use block wait lock
        if(gotLock == 0) {
                pthread_mutex_lock(&(NeonAccessLock[socket_select]));
        }
        int sock = neon_api_socket[socket_select];


        uint8_t *buffer = (uint8_t *)malloc(8192);
        uint8_t *buffer_ptr = buffer;
        prepare_nblocks_msg(&buffer_ptr, requestLsn, notModifiedSinceLsn, spcId, dbId, relId, forkNum);

        // Send the message to the server
        send(sock, buffer, buffer_ptr - buffer, 0);

        free(buffer);

        // Receive the response from the server
        uint8_t response_orig[8192];
        uint8_t *response = response_orig;
        int bytes_received = recv(sock, response_orig, sizeof(response_orig), 0);
        if (bytes_received < 0) {
            perror("Failed to receive data from the Neon API server");
            close(sock);
            exit(EXIT_FAILURE);
        }
        // printf("%s %d, received %d bytes from neon's NBlocks API\n", __func__, __LINE__, bytes_received);
        pthread_mutex_unlock(&(NeonAccessLock[socket_select]));

        // The first byte of the response is the Copy-both message type
        Assert(response[0] == 'd');
        // printf("response type: %c\n", response[0]);
        response += 1;

        // Then following a u32 value to indicate the value length, which should be 8191
        uint32_t value_length = ntohl(*(uint32_t *)(response));
        // printf("remaining value length: %u\n", value_length);
        response += 4;
        if(value_length != 9) {
            printf("value_length != 9, content = %s\n", response);
            return -1;
        }

        // The next 1 byte is the NBlocks tag, which should be 'd'
        Assert(response[0] == 101);
        // printf("NBlocks tag: %d\n", response[0]);
        response += 1;

        // The next 4 bytes is the result, which should be a u32 value
        uint32_t result = ntohl(*(uint32_t *)(response));
        // printf("NBlocks result: %u\n", result);

        return result;
}

char* get_page_from_neon_api(uint64_t requestLsn, uint64_t notModifiedSinceLsn, uint32_t spcId, uint32_t dbId, uint32_t relId, uint8_t forkNum, uint32_t blockNum) {
        requestLsn = requestLsn - LsnLatency;
        notModifiedSinceLsn = notModifiedSinceLsn - LsnLatency;

        int tid = gettid();
        int socket_select = tid%NeonApiSocketNum;
        int gotLock = 0;
        for(int i = 0; i < NeonApiSocketNum; i++) {
                if(pthread_mutex_trylock( &(NeonAccessLock[ (socket_select+i)%NeonApiSocketNum ]) ) == 0) { // Lock successfully
                        gotLock = 1;
                        socket_select = (socket_select+i) % NeonApiSocketNum;
                        break;
                }
        }

        // if we didn't get lock with trylock(), then use block wait lock
        if(gotLock == 0) {
                pthread_mutex_lock(&(NeonAccessLock[socket_select]));
        }
        int sock = neon_api_socket[socket_select];

        uint8_t *buffer = (uint8_t *)malloc(8192);
        uint8_t *buffer_ptr = buffer;
        prepare_get_page_query(&buffer_ptr, requestLsn, notModifiedSinceLsn, spcId, dbId, relId, forkNum, blockNum);

        // Send the message to the server
        send(sock, buffer, buffer_ptr - buffer, 0);

        free(buffer);

        // Receive the response from the server
        uint8_t orig_response[8192+168];
        int bytes_received = recv(sock, orig_response, sizeof(orig_response), 0);
        if (bytes_received < 0) {
            perror("Failed to receive data from the Neon API server");
            close(sock);
            exit(EXIT_FAILURE);
        }
        // printf("%s %d, received %d bytes from neon's GetPage API\n", __func__, __LINE__, bytes_received);
        pthread_mutex_unlock(&(NeonAccessLock[socket_select]));

        uint8_t *response = orig_response;

        // Parse the response

        Assert(bytes_received == 8198);

        // The first byte of the response is the Copy-both message type
        Assert(response[0] == 'd');
        // printf("response type: %c\n", response[0]);
        response += 1;

        // Then following a u32 value to indicate the value length, which should be 8197
        uint32_t value_length = ntohl(*(uint32_t *)(response));
        // printf("remaining value length: %u\n", value_length);
        Assert(value_length == 8197);
        response += 4;
        if(value_length != 8197) {
            printf("value_length != 8197, content = %s\n", response);
            return NULL;
        }

        // The next 1 byte is the GetPage tag, which should be 'f'
        Assert(response[0] == 'f');
        // printf("GetPage tag: %c\n", response[0]);
        response += 1;


        uint8_t *response_str = (uint8_t*) malloc(8192 + 128);
        uint16_t specialSpace = PageGetSpecialSize(response);
        // printf("specialSpace = %u\n", specialSpace);

        memcpy(response_str, response, 8192);
        response_str[8192] = '\0';

        return (char*) response_str;
}

int start_server(int port)
{
        int server_fd, new_socket;
        struct sockaddr_in address;
        int addrlen = sizeof(address);

        // Creating socket file descriptor
        if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0)
        {
                perror("socket failed");
                return -1;
        }

        // Bind the socket to the port
        address.sin_family = AF_INET;
        address.sin_addr.s_addr = INADDR_ANY;
        address.sin_port = htons(port);

        if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0)
        {
                perror("bind failed");
                close(server_fd);
                return -1;
        }

        // Listen for incoming connections
        if (listen(server_fd, 5) < 0)
        {
                perror("listen failed");
                close(server_fd);
                return -1;
        }

        // printf("Listening on port %d...\n", port);

        // Accept a connection request
        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen)) < 0)
        {
                perror("accept failed");
                close(server_fd);
                return -1;
        }

        // printf("Connection from %s:%d has been established.\n", inet_ntoa(address.sin_addr), ntohs(address.sin_port));

        // Close the server socket as it's no longer needed
        close(server_fd);

        // Read data from the client
        uint8_t data[8192];
        int bytes_received = recv(new_socket, data, sizeof(data), 0);
        if (bytes_received < 8)
        {
                fprintf(stderr, "Received data is less than 8 bytes, unable to extract u32 values\n");
                close(new_socket);
                return -1;
        }
        int remaining_bytes = bytes_received;

        // Extract the first u32
        uint32_t u32_value1 = ntohl(*(uint32_t *)(data));
        // printf("First 4 bytes as u32: %u\n", u32_value1);

        // Extract the second u32
        uint32_t u32_value2 = ntohl(*(uint32_t *)(data + 4));
        // printf("Second 4 bytes as u32: %u\n", u32_value2);

        // Follow the Rust code logic
        uint16_t req_hi = u32_value2 >> 16;
        uint16_t req_lo = u32_value2 & ((1 << 16) - 1);
        // printf("req_hi: %u, req_lo: %u\n", req_hi, req_lo);

        // Process the rest of the message
        char *msg_str = (char *)(data + 8);
        remaining_bytes -= 8;

        if (msg_str[remaining_bytes - 1] != '\0')
        {
                fprintf(stderr, "StartupMessage params: missing null terminator\n");
                close(new_socket);
                return -1;
        }

        char *token;
        token = strtok(msg_str, "\0");
        if (!token)
        {
                fprintf(stderr, "StartupMessage params: key without value\n");
                close(new_socket);
                return -1;
        }

        // Prepare the response messages
        uint8_t *response_buffer = (uint8_t *)malloc(8192);
        uint8_t *response_ptr = response_buffer;
        prepare_authentication_ok(&response_ptr);
        prepare_parameter_status(&response_ptr, "client_encoding", "UTF8");
        prepare_parameter_status(&response_ptr, "integer_datetimes", "on");
        prepare_parameter_status(&response_ptr, "server_version", "14.0");
        prepare_ready_for_query(&response_ptr);

        // printf("buffer = %.*s", response_ptr - response_buffer);

        // Send all prepared messages at once
        send(new_socket, response_buffer, response_ptr - response_buffer, 0);
        // printf("Sent all prepared messages to the client.\n");
        fflush(stdout);

        free(response_buffer);

        return new_socket;
}

void* process_neon_xlog_resp(void* arg)
{
        printf("process xlog response thread started\n");
        fflush(stdout);
        // Read from the socket_fd, and print the response
        uint8_t data[8192];
        int data_len = 0;
        do{
                data_len = recv(neon_socket, data, sizeof(data), 0);
                if(data_len > 0) {
                        // Print the data out
                        // printf("RpcServer received xlog data from Neon engine, len = %d, data = ", data_len);
                        // for (int i = 0; i < data_len; i++)
                        // {
                        //         printf("%c", data[i]);
                        // }
                        // printf("\n");
                        // fflush(stdout);
                }
        } while(data_len > 0);
        printf("process xlog response thread ended\n");

        return NULL;
}

// Receive msg from socket and print them out
// Use prepare_copy_both_response to prepare the response
// Send the response back to client
int process_start_replication_cmd(int socket_fd)
{
        // Read data from client
        uint8_t data[8192];
        int bytes_received = recv(socket_fd, data, sizeof(data), 0);

        // Print the data out
        printf("RpcServer received replication cmd data from Neon engine, len = %d, data = ", bytes_received);
        for (int i = 0; i < bytes_received; i++)
        {
                printf("%c", data[i]);
        }
        printf("\n");

        std::string part1, part2;
        std::string rep_str = std::string((char *)data+7);
        // data example: "Q)START_REPLICATION PHYSICAL 0/1696948"
        // Find the position of the slash (/) in the string
        size_t slashPos = rep_str.find('/');
        if (slashPos != std::string::npos) {
                // Extract the part after the space before the slash (0 in this case)
                size_t spacePos = rep_str.find_last_of(' ', slashPos);
                part1 = rep_str.substr(spacePos + 1, slashPos - spacePos - 1);
        
                // Extract the part after the slash (1696948 in this case)
                part2 = rep_str.substr(slashPos + 1);
        } else {
                printf("Invalid replication command format\n");
        }


        // Convert the lower_part to uint64_t
        uint64_t NeonStartupLSN_low = strtoull(part2.c_str(), NULL, 16);
        // Convert the upper_part to uint64_t
        uint64_t NeonStartupLSN_high = strtoull(part1.c_str(), NULL, 16);

        NeonStartupLSN = (NeonStartupLSN_high << 32) | NeonStartupLSN_low;
        printf("NeonStartupLSN = %lu\n", NeonStartupLSN);

        // Prepare the response
        uint8_t *response_buffer = (uint8_t *)malloc(8192);
        uint8_t *response_ptr = response_buffer;
        prepare_copy_both_response(&response_ptr);

        // Send the response back to client
        send(socket_fd, response_buffer, response_ptr - response_buffer, 0);
        // printf("Sent the start_replication response back to the client.\n");

        free(response_buffer);
        return 0;
}

int send_xlog_to_neon_engine(int socket_fd, uint64_t walStart, uint64_t walEnd, int64_t timeStamp, uint64_t dataSize, const char *xlogBody)
{
        // Prepare the XLog message
        uint8_t *response_buffer = (uint8_t *)malloc(dataSize + 8192);

        uint8_t *response_ptr = response_buffer;
        prepare_xlog_msg(&response_ptr, walStart, walEnd, timeStamp, dataSize, xlogBody);

        // printf("%s %d\n", __func__, __LINE__);
        // fflush(stdout);

        // Send the XLog message to the client
        ssize_t msg_len = send(socket_fd, response_buffer, response_ptr - response_buffer, 0);
        if(msg_len != response_ptr - response_buffer) {
                printf("Failed to send the XLog message back to the client.\n");
                return -1;
        }
        // printf("%s %d, have_dataSize = %lu, actual_sentSize = %u\n", __func__, __LINE__, dataSize, msg_len);
        // fflush(stdout);

        // printf("Sent the XLog message back to the client.\n");

        free(response_buffer);

        // Read from the socket_fd, and print the response
        // uint8_t data[8192];
        // int bytes_received = recv(socket_fd, data, sizeof(data), 0);

        // // Print the data out
        // printf("%s, RpcServer received xlog data from Neon engine, len = %d, data = ", __func__, bytes_received);
        // for(int i = 0; i < bytes_received; i++) {
        //         printf("%c", data[i]);
        // }
        // printf("\n");

        return 0;
}

// endLSN is not included
void SyncXLogWithNeonUntilLSN(int socketFd, uint64_t startLsn, uint64_t endLsn)
{
        // printf("%s %d, startLsn = %lu, endLsn = %lu\n", __func__, __LINE__, startLsn, endLsn);
        uint64_t xlogBufferSize = 8192 * 1600;
        char *xlogBuffer = (char *)malloc(xlogBufferSize);

        uint64_t currentLsn = startLsn;
        int segNo;
        int fd = 0;

        // Initialize the Segno
        XLByteToSeg(currentLsn, segNo, wal_segment_size);

        while (currentLsn < endLsn)
        {
                if (fd == 0 || !XLByteInSeg(currentLsn, segNo, wal_segment_size))
                {
                        // Recalculate the segno
                        XLByteToSeg(currentLsn, segNo, wal_segment_size);

                        if (fd != 0)
                                close(fd);
                        
                        char xlogFilePath[MAXPGPATH];
                        XLogFilePath(xlogFilePath, 1, segNo, wal_segment_size);
                        fd = BasicOpenFile(xlogFilePath, O_RDONLY | PG_BINARY);
                        if (fd < 0) {
                                printf("%s, Failed to open file %s\n", __func__, xlogFilePath);
                                return;
                        }
                }

                // Now we can read the XLog file content
                uint64_t segmentEndPtr = (segNo+1) * wal_segment_size;
                uint64_t segmentRemaining = segmentEndPtr - currentLsn;

                uint64_t toReadRestSize = endLsn - currentLsn;

                uint64_t expectedSize = MIN(toReadRestSize, segmentRemaining);
                expectedSize = MIN(expectedSize, xlogBufferSize);


                uint64_t segmentOffset = currentLsn % wal_segment_size;
                // printf("%s %d, pg_pread currentLsn = %lu, segmentOffset = %lu, expectedSize = %d\n", __func__, __LINE__, currentLsn, segmentOffset, expectedSize);
                uint64_t readSize = pg_pread(fd, xlogBuffer, expectedSize, segmentOffset);
                if (readSize < 0) {
                        printf("%s, Failed to read file\n", __func__);
                        return;
                }

                // Send the XLog message to the Neon
                printf("%s %d, send xlog to neon engine, startLSN = %lu, endLSN = %lu\n", __func__, __LINE__, currentLsn, currentLsn + readSize);
                send_xlog_to_neon_engine(socketFd, currentLsn, currentLsn + readSize, 0, readSize, xlogBuffer);

                currentLsn += readSize;
        }

        if (fd != 0)
                close(fd);
        free(xlogBuffer);
}

extern XLogRecPtr XLogParseUpto;

static void TransRelNode2RelKey(RelFileNode node, RelKey *relKey, ForkNumber forkNumber)
{
        relKey->SpcId = node.spcNode;
        relKey->DbId = node.dbNode;
        relKey->RelId = node.relNode;

        relKey->forkNum = forkNumber;
        return;
}
#include <sys/time.h>

pthread_mutex_t wakeupMutex;
void WaitParse(int64_t _lsn)
{

        //    struct timeval now;
        //    gettimeofday(&now, NULL);
        //    printf("parameter_lsn = %lu, second = %lu, us = %lu\n",
        //           _lsn, now.tv_sec, now.tv_usec);
        //    fflush(stdout);

        //    if(WalRcvRunning() == false)
        //        return;
        //    XLogRecPtr flushUpto = WalRcv->flushedUpto;
        //    if((XLogRecPtr)_lsn > XLogParseUpto && XLogParseUpto < flushUpto && XLogParseUpto != 0) {
        if ((XLogRecPtr)_lsn > XLogParseUpto && XLogParseUpto < RpcXLogFlushedLsn && XLogParseUpto != 0)
        {
#ifdef ENABLE_DEBUG_INFO
                printf("%s %d , parameter_lsn = %lu, ParseUpto = %lu, flushUpto = %lu\n",
                       __func__, __LINE__, _lsn, XLogParseUpto, RpcXLogFlushedLsn);
                fflush(stdout);
#endif
                XLogRecPtr targetLsn = RpcXLogFlushedLsn;
                if (_lsn < targetLsn)
                        targetLsn = _lsn;

                XLogRecPtr prevParse = XLogParseUpto;

                int count = 0;
                XLogRecPtr tempRecord = 0;
                while (XLogParseUpto < targetLsn - 64 && !reachXlogTempEnd)
                {
                        if (XLogParseUpto != tempRecord)
                        {
                                //                if(count >= 50) {
                                //                    printf("%s %d, clog lsn = %lu, target lsn = %lu, count = %d\n", __func__ ,
                                //                           __LINE__, XLogParseUpto, targetLsn, count);
                                //                    fflush(stdout);
                                //                }
                                tempRecord = XLogParseUpto;
                                count = 0;
                        }
                        else
                        {
                                count++;
                        }

//            if(count == 4) {
//                XLogParseUpto = targetLsn;
//            }
//            printf("%s %d keep waiting , parameter_lsn = %lu, ParseUpto = %lu, flushUpto = %lu\n",
//                   __func__ , __LINE__, _lsn, XLogParseUpto, flushUpto);
//            fflush(stdout);
#ifdef ENABLE_DEBUG_INFO
                        count++;
                        if (count % 10 == 0)
                        {
                                printf("%s %d keep waiting , parameter_lsn = %lu, ParseUpto = %lu, flushUpto = %lu\n",
                                       __func__, __LINE__, _lsn, XLogParseUpto, RpcXLogFlushedLsn);
                                fflush(stdout);
                                count = 0;
                        }
#endif

                        //            printf("%s get into sleep\n", __func__ );
                        //            fflush(stdout);
                        usleep(500);
                        //            pthread_mutex_lock(&wakeupMutex);
                        //            WakeupRecovery();
                        //            WakeupStartupRecovery();
                        //            pthread_mutex_unlock(&wakeupMutex);
                        //            if(reachXlogTempEnd && XLogParseUpto != prevParse) {
                        //                reachXlogTempEnd = 0;
                        //            }
                        //            if(reachXlogTempEnd) {
                        //                waitCount++;
                        //            }
                }

                if (reachXlogTempEnd)
                {
                        reachXlogTempEnd = 0;
                }
        }
        //    printf("%s %d exit\n" ,__func__ , __LINE__);
        //    fflush(stdout);
}

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace ::tutorial;
class DataPageAccessHandler : virtual public DataPageAccessIf
{
public:
        DataPageAccessHandler()
        {
                // Your initialization goes here
        }

        /**
         * A method definition looks like C code. It has a return type, arguments,
         * and optionally a list of exceptions that it may throw. Note that argument
         * lists and exception lists are specified using the exact same syntax as
         * field lists in struct or exception definitions.
         *
         * @param _fd
         */

        void
        ReadBufferCommon(_Page &_return, const _Smgr_Relation &_reln, const int32_t _relpersistence, const int32_t _forknum,
                         const int32_t _blknum, const int32_t _readBufferMode, const int64_t _lsn)
        {
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif

                // printf("%s %d start, spc = %lu, db = %lu, rel = %lu, fork = %d, blk = %d, lsn = %lu, tid = %d, current_neon_flush_lsn=%lu\n", __func__ , __LINE__,
                //       _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum, _lsn, gettid(), NeonFlushedLSN);
                // fflush(stdout);
#ifdef NeonAsRemoteStorageEngine


                uint8_t relExists = relexists_from_neon_api(_lsn, _lsn, _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum);
                // printf("ReadBufferCommon, relExists = %d\n", relExists);
                // fflush(stdout);

                if(relExists == 0) {
                        // Try to get page from RocksDB.
                        RelFileNode rnode;
                        rnode.spcNode = _reln._spc_node;
                        rnode.dbNode = _reln._db_node;
                        rnode.relNode = _reln._rel_node;

                        BufferTag bufferTag;
                        INIT_BUFFERTAG(bufferTag, rnode, (ForkNumber)_forknum, (BlockNumber)_blknum);

                        char *buff = (char *)malloc(BLCKSZ);
                        GetBasePage(rnode, (ForkNumber)_forknum, (BlockNumber)_blknum, buff);

                        _return.assign(buff, BLCKSZ);
                        free(buff);

                        // char* empty_page = (char*)malloc(BLCKSZ);
                        // memset(empty_page, 0, BLCKSZ);
                        // _return.assign(empty_page, BLCKSZ);
                        return;
                }

                // uint32_t nblocks = nblocks_from_neon_api(_lsn-lsn_latency, _lsn-lsn_latency, _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum);
                // printf("ReadBufferCommon, nblocks = %u\n", nblocks);
                // fflush(stdout);

                char * neon_page = get_page_from_neon_api(_lsn, _lsn, _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum);

                uint64_t return_lsn = PageGetLSN(neon_page);
                // printf("ReadBufferCommon, return_lsn = %lu\n", return_lsn);
                // fflush(stdout);

                _return.assign(neon_page, BLCKSZ);
                free(neon_page);
                return;

#endif
                
                WaitParse(_lsn);

                RelFileNode rnode;
                rnode.spcNode = _reln._spc_node;
                rnode.dbNode = _reln._db_node;
                rnode.relNode = _reln._rel_node;

                KeyType key;
                key.SpcID = _reln._spc_node;
                key.DbID = _reln._db_node;
                key.RelID = _reln._rel_node;
                key.ForkNum = _forknum;
                key.BlkNum = _blknum;

                uint64_t replayedLsn;
                uint64_t *toReplayList;
                int listSize = 0;
                int found = HashMapGetBlockReplayList(pageVersionHashMap, key, _lsn, &replayedLsn, &toReplayList, &listSize);

                if (!found || replayedLsn <= 0ull && listSize == 0)
                {

                        BufferTag bufferTag;
                        INIT_BUFFERTAG(bufferTag, rnode, (ForkNumber)_forknum, (BlockNumber)_blknum);
                        char *buff = (char *)malloc(BLCKSZ);
                        GetBasePage(rnode, (ForkNumber)_forknum, (BlockNumber)_blknum, buff);

                        _return.assign(buff, BLCKSZ);

                        //            HashMapInsertKey(pageVersionHashMap, key, 1, -1, true);
                        //            HashMapUpdateReplayedLsn(pageVersionHashMap, key, 1, false);
                        //            PutPage2Rocksdb(bufferTag, 1, buff);
                        free(buff);

                        //            printf("%s %d, spc = %lu, db = %lu, rel = %lu, fork = %d, blk = %d, lsn = %lu, tid = %d\n", __func__ , __LINE__,
                        //                   _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum, _lsn, gettid());
                        //            fflush(stdout);

                        return;
                }

                // Then replayLSN is what we needed from RocksDB
                if (listSize == 0)
                {
                        char *targetPage = NULL;

                        BufferTag bufferTag;
                        INIT_BUFFERTAG(bufferTag, rnode, (ForkNumber)_forknum, (BlockNumber)_blknum);
                        GetPageFromRocksdb(bufferTag, replayedLsn, &targetPage);

                        _return.assign(targetPage, BLCKSZ);
                        free(targetPage);
                        //            printf("%s %d, spc = %lu, db = %lu, rel = %lu, fork = %d, blk = %d, lsn = %lu, tid = %d\n", __func__ , __LINE__,
                        //                   _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum, _lsn, gettid());
                        //            fflush(stdout);
                        return;
                }

                // For now, we need to replay several xlogs until we get the expected version
                // The xlog sublist we need to replay is [ uintList[1]+2 , foundPos ]

                char *page2 = (char *)malloc(BLCKSZ);

                //! Print all the lsn in the list
                //        printf("%s %d, tid = %d, listsize = %d, replayedLSN = %lu\n", __func__ , __LINE__, gettid(), listSize, replayedLsn);
                //        fflush(stdout);
                //        for(int i = 0; i < listSize; i++) {
                //            printf("%lu , tid = %d\n", toReplayList[i], gettid());
                //            fflush(stdout);
                //        }

                BufferTag bufferTag;
                INIT_BUFFERTAG(bufferTag, rnode, (ForkNumber)_forknum, (BlockNumber)_blknum);

                if (replayedLsn > 0)
                {
                        char *basePage = NULL;
                        GetPageFromRocksdb(bufferTag, replayedLsn, &basePage);
                        ApplyLsnList(rnode, (ForkNumber)_forknum, (BlockNumber)_blknum, reinterpret_cast<XLogRecPtr *>(toReplayList),
                                     listSize, basePage, page2);
                        free(basePage);
                }
                else
                {
                        ApplyLsnListAndGetUpdatedPage(rnode, (ForkNumber)_forknum, (BlockNumber)_blknum, reinterpret_cast<XLogRecPtr *>(toReplayList),
                                                      listSize, page2);
                }

                PutPage2Rocksdb(bufferTag, toReplayList[listSize - 1], page2);

                if (listSize > 0)
                {
                        HashMapUpdateReplayedLsn(pageVersionHashMap, key, toReplayList[listSize - 1], true);

                        free(toReplayList);
#ifdef ENABLE_FUNCTION_TIMING
                        functionTiming.RecordTime(__LINE__);
#endif
                }

                HashMapGarbageCollectKey(pageVersionHashMap, key);

                //        printf("%s %d end, targetPageLsn = %lu, spc = %lu, db = %lu, rel = %lu, fork = %d, blk = %d, lsn = %lu, tid = %d\n", __func__ , __LINE__,
                //               PageGetLSN(page2), _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum, _lsn, gettid());
                //        fflush(stdout);

#ifdef DEBUG_TIMING
                RECORD_TIMING(&start, &end, &readBufferCommon[14], &readBufferCount[14])
#endif

                // TODO: Return page2
                //  Set the desired page version as return value
                _return.assign(page2, BLCKSZ);

                free(page2);

#ifdef DEBUG_TIMING
                RECORD_TIMING(&start, &end, &readBufferCommon[15], &readBufferCount[15])
#endif
        }

        int32_t RpcRegisterSecondaryNode(bool _primary, int64_t _lsn){
                return HashMapRegisterSecondaryNode(pageVersionHashMap, _primary, _lsn);
        }

        void RpcSecondaryNodeUpdatesLsn(int32_t _node_id, int64_t _lsn){
                HashMapSecondaryNodeUpdatesLsn(pageVersionHashMap, _node_id, _lsn);
        }

        void RpcNeonHeartbeat(){
#ifdef NeonAsRemoteStorageEngine
                if(neon_api_arguments_for_heartbeat.initialized)
                        for(int i = 0; i < NeonApiSocketNum; i++)
                                relexists_from_neon_api(neon_api_arguments_for_heartbeat.requestLsn, neon_api_arguments_for_heartbeat.notModifiedSinceLsn,
                                        neon_api_arguments_for_heartbeat.spcId, neon_api_arguments_for_heartbeat.dbId,
                                        neon_api_arguments_for_heartbeat.relId, neon_api_arguments_for_heartbeat.forkNum);
#endif
        }

        void RpcMdRead(_Page &_return, const _Smgr_Relation &_reln, const int32_t _forknum, const int64_t _blknum, const int64_t _lsn)
        {
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef ENABLE_DEBUG_INFO
                printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, blkNum = %ld\n", __func__, __FILE__, __LINE__,
                       _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum);
                fflush(stdout);
#endif
                RelFileNode rnode;
                rnode.spcNode = _reln._spc_node;
                rnode.dbNode = _reln._db_node;
                rnode.relNode = _reln._rel_node;
                SMgrRelation smgrReln = smgropen(rnode, InvalidBackendId);

                WaitParse(_lsn);

                char buff[BLCKSZ];
                GetPageByLsn(rnode, (ForkNumber)_forknum, _blknum, 0, buff);
                _return.assign(buff, BLCKSZ);

#ifdef ENABLE_DEBUG_INFO
                printf("%s End\n", __func__);
#endif
                //        RelationData relationData;
                //        memset(&relationData, 0, sizeof(RelationData));
                //        Relation relation = &relationData;
                //        relation->rd_smgr = smgrReln;

                // Not guarantee right
                //        FormData_pg_class formDataPgClass;
                //        formDataPgClass.relpersistence = RELPERSISTENCE_PERMANENT;
                //        relation->rd_rel = &formDataPgClass;
                //
                //        Buffer buff = ReadBufferExtended(relation, (ForkNumber)_forknum, _blknum, RBM_NORMAL, NULL);
                //
                //        LockBuffer(buff, BUFFER_LOCK_SHARE);
                //        char* page;
                //        page = BufferGetPage(buff);
                //
                //        char tempPage[BLCKSZ];
                //        memcpy(tempPage, page, BLCKSZ);
                //
                //        _return.resize(BLCKSZ);
                //        _return.assign(tempPage, BLCKSZ);
                //
                //        UnlockReleaseBuffer(buff);

                //        char page[BLCKSZ+16];
                //        mdread(smgrReln, (ForkNumber)_forknum, _blknum, page);
                //        _return.assign(page, BLCKSZ);
                //
                //        printf("%s end\n", __func__ );
                //        fflush(stdout);
        }

        int32_t RpcMdNblocks(const _Smgr_Relation &_reln, const int32_t _forknum, const int64_t _lsn)
        {
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef ENABLE_DEBUG_INFO2
                printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, lsn = %ld tid=%d\n", __func__, __FILE__, __LINE__,
                       _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _lsn, gettid());
                fflush(stdout);
#endif
                // Your implementation goes here
                //        SyncReplayProcess();

#ifdef NeonAsRemoteStorageEngine
                uint32_t nblocks = nblocks_from_neon_api(_lsn, _lsn, _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum);
                // printf("ReadBufferCommon, nblocks = %u\n", nblocks);
                // fflush(stdout);
                return nblocks;
#endif
#ifdef DEBUG_TIMING
                struct timeval start, end;
                START_TIMING(&start);
#endif
                WaitParse(_lsn);

#ifdef DEBUG_TIMING
                RECORD_TIMING(&start, &end, &nblocksTime[4], &nblocksCount[4])
#endif
                RelFileNode rnode;
                rnode.spcNode = _reln._spc_node;
                rnode.dbNode = _reln._db_node;
                rnode.relNode = _reln._rel_node;
                //        SMgrRelation smgrReln = smgropen(rnode, InvalidBackendId);

                XLogRecPtr lsn = _lsn;
                RelKey relKey;
                TransRelNode2RelKey(rnode, &relKey, (ForkNumber)_forknum);

#ifdef DEBUG_TIMING
                RECORD_TIMING(&start, &end, &nblocksTime[0], &nblocksCount[0])
#endif

                uint32_t foundPageNum = 0;
                //        printf("%s %d\n", __func__ , __LINE__);
                //        fflush(stdout);
                RelSizePthreadReadLock(relKey);
                if (GetRelSizeCache(relKey, &foundPageNum))
                {
                        RelSizePthreadUnlock(relKey);
#ifdef ENABLE_DEBUG_INFO2
                        printf("%s cached, pageNum = %u\n", __func__, foundPageNum);
                        fflush(stdout);
#endif
#ifdef DEBUG_TIMING
                        RECORD_TIMING(&start, &end, &nblocksTime[1], &nblocksCount[1])
#endif
                        return (int32_t)foundPageNum;
                }
                //        printf("%s %d\n", __func__ , __LINE__);
                //        fflush(stdout);
                RelSizePthreadUnlock(relKey);

#ifdef DEBUG_TIMING
                RECORD_TIMING(&start, &end, &nblocksTime[2], &nblocksCount[2])
#endif
                int relSize = SyncGetRelSize(rnode, (ForkNumber)_forknum, 0);
#ifdef ENABLE_DEBUG_INFO2
                printf("%s get relsize=%d from standalone pg\n", __func__, relSize);
                fflush(stdout);
#endif
                //        printf("%s %d\n", __func__ , __LINE__);
                //        fflush(stdout);
                RelSizePthreadWriteLock(relKey);
                uint32 tempResult = 0;
                if (relSize >= 0 && GetRelSizeCache(relKey, &tempResult) == false)
                        InsertRelSizeCache(relKey, (uint32)relSize);
                RelSizePthreadUnlock(relKey);
//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);

//        BlockNumber result = mdnblocks(smgrReln, (ForkNumber)_forknum);
#ifdef ENABLE_DEBUG_INFO
                printf("%s end\n", __func__);
                fflush(stdout);
#endif

#ifdef DEBUG_TIMING
                RECORD_TIMING(&start, &end, &nblocksTime[3], &nblocksCount[3])
#endif
                return relSize;
        }

        int32_t RpcMdExists(const _Smgr_Relation &_reln, const int32_t _forknum, const int64_t _lsn)
        {
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef DEBUG_TIMING
                struct timeval start, end;
                START_TIMING(&start);
#endif
#ifdef ENABLE_DEBUG_INFO
                printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, lsn = %ld tid=%d\n", __func__, __FILE__, __LINE__,
                       _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _lsn, gettid());
                fflush(stdout);
#endif

                WaitParse(_lsn);
                //        SyncReplayProcess();

                RelFileNode rnode;
                rnode.spcNode = _reln._spc_node;
                rnode.dbNode = _reln._db_node;
                rnode.relNode = _reln._rel_node;

                RelKey relKey;
                TransRelNode2RelKey(rnode, &relKey, (ForkNumber)_forknum);

                uint32_t foundPageNum;
                RelSizePthreadReadLock(relKey);
                int found = GetRelSizeCache(relKey, &foundPageNum);
                RelSizePthreadUnlock(relKey);
#ifdef DEBUG_TIMING
                RECORD_TIMING(&start, &end, &existsTime[0], &existsCount[0])
#endif
                if (found)
                {
//            printf("%s %d\n", __func__ , __LINE__);
//            fflush(stdout);
#ifdef DEBUG_TIMING
                        RECORD_TIMING(&start, &end, &existsTime[1], &existsCount[1])
#endif
                        return 1;
                }
                //        printf("%s %d\n", __func__ , __LINE__);
                //        fflush(stdout);

                //        SMgrRelation smgrReln = smgropen(rnode, InvalidBackendId);
                //        int32_t result = mdexists(smgrReln, (ForkNumber)_forknum);

#ifdef DEBUG_TIMING
                RECORD_TIMING(&start, &end, &existsTime[2], &existsCount[2])
#endif
                int relSize = SyncGetRelSize(rnode, (ForkNumber)_forknum, _lsn);
#ifdef ENABLE_DEBUG_INFO
                printf("%s get relsize=%d from standalone pg\n", __func__, relSize);
#endif
                uint32 tempResult = -1;
                RelSizePthreadWriteLock(relKey);
                if (relSize >= 0 && GetRelSizeCache(relKey, &tempResult) == false)
                        InsertRelSizeCache(relKey, (uint32)relSize);
                RelSizePthreadUnlock(relKey);
                //        printf("%s %d\n", __func__ , __LINE__);
                //        fflush(stdout);

#ifdef ENABLE_DEBUG_INFO
                printf("%s result = %d end\n", __func__, relSize);
                fflush(stdout);
#endif
#ifdef DEBUG_TIMING
                RECORD_TIMING(&start, &end, &existsTime[3], &existsCount[3])
#endif
                return (relSize >= 0);
        }

        void RpcMdCreate(const _Smgr_Relation &_reln, const int32_t _forknum, const int32_t _isRedo, const int64_t _lsn)
        {
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef ENABLE_DEBUG_INFO
                printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, lsn = %lu tid=%d\n", __func__, __FILE__, __LINE__,
                       _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _lsn, gettid());
                fflush(stdout);
#endif

                RelFileNode rnode;
                rnode.spcNode = _reln._spc_node;
                rnode.dbNode = _reln._db_node;
                rnode.relNode = _reln._rel_node;

#ifdef PASS
                //        SyncReplayProcess();
                WaitParse(_lsn);

                RelKey relKey;
                TransRelNode2RelKey(rnode, &relKey, (ForkNumber)_forknum);
                //        printf("%s %d\n", __func__ , __LINE__);
                //        fflush(stdout);

                uint64_t foundLsn;
                uint32 foundPageNum;
                RelSizePthreadWriteLock(relKey);
                int found = GetRelSizeCache(relKey, &foundPageNum);
                if (!found)
                {
                        InsertRelSizeCache(relKey, 0);
                }
                RelSizePthreadUnlock(relKey);
#endif

                //        printf("%s %d\n", __func__ , __LINE__);
                //        fflush(stdout);

                WalRedoCreateRel(rnode, (ForkNumber)_forknum);

#ifdef ENABLE_DEBUG_INFO
                printf("%s end\n", __func__);
                fflush(stdout);
#endif
        }

        void RpcMdExtend(const _Smgr_Relation &_reln, const int32_t _forknum, const int32_t _blknum, const _Page &_buff, const int32_t skipFsync, const int64_t _lsn)
        {
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef ENABLE_DEBUG_INFO
                printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, blknum = %d lsn = %ld tid=%d\n", __func__, __FILE__, __LINE__,
                       _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum, _lsn, gettid());
                fflush(stdout);
#endif

                RelFileNode rnode;
                rnode.spcNode = _reln._spc_node;
                rnode.dbNode = _reln._db_node;
                rnode.relNode = _reln._rel_node;

#ifdef PASS
                //        SyncReplayProcess();
                WaitParse(_lsn);

                RelKey relKey;
                TransRelNode2RelKey(rnode, &relKey, (ForkNumber)_forknum);

                //        printf("%s %d\n", __func__ , __LINE__);
                //        fflush(stdout);
                uint64_t foundLsn;
                uint32_t foundPageNum;
                RelSizePthreadWriteLock(relKey);
                int found = GetRelSizeCache(relKey, &foundPageNum);
                // TODO: Here may have some problems: extend-page content's lsn is larger than parameter lsn
#ifdef ENABLE_DEBUG_INFO
                printf("%s %d\n", __func__, __LINE__);
                fflush(stdout);
#endif
                if (!found || foundPageNum < _blknum + 1)
                {
                        InsertRelSizeCache(relKey, _blknum + 1);
                }
                RelSizePthreadUnlock(relKey);
#endif

//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);
#ifdef ENABLE_DEBUG_INFO
                printf("%s %d\n", __func__, __LINE__);
                fflush(stdout);
#endif
                BufferTag tag;
                INIT_BUFFERTAG(tag, rnode, (ForkNumber)_forknum, (BlockNumber)_blknum);
                char *extendPage = (char *)malloc(BLCKSZ);

                _buff.copy(extendPage, BLCKSZ);

                //        if(_blknum == 10 && rnode.relNode == 2659)
                //            PageSetLSN(extendPage, 2);

#ifdef ENABLE_DEBUG_INFO
                printf("%s %d, parameter lsn = %lu\n", __func__, __LINE__, PageGetLSN(extendPage));
                fflush(stdout);
#endif

                // TODO: maybe it not this reason
                /*!
                 *  Important: Before we put this extended page to
                 */
                // Put version:-1 to RocksDB
                //        PutPage2Rocksdb(tag, 1, extendPage);
                WalRedoExtendRel(rnode, (ForkNumber)_forknum, (BlockNumber)_blknum, extendPage);
                free(extendPage);
//        char extendPage[BLCKSZ+16];
//        _buff.copy(extendPage, BLCKSZ);
//
#ifdef ENABLE_DEBUG_INFO
                printf("%s end\n", __func__);
                fflush(stdout);
#endif
        }

        void RpcTruncate(const _Smgr_Relation &_reln, const int32_t _forknum, const int32_t _blknum, const int64_t _lsn)
        {
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef ENABLE_DEBUG_INFO
                printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, blknum = %d lsn = %ld tid=%d\n", __func__, __FILE__, __LINE__,
                       _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum, _lsn, gettid());
                fflush(stdout);
#endif

                WaitParse(_lsn);

                RelFileNode rnode;
                rnode.spcNode = _reln._spc_node;
                rnode.dbNode = _reln._db_node;
                rnode.relNode = _reln._rel_node;

                //        printf("%s %d\n", __func__ , __LINE__);
                //        fflush(stdout);
                RelKey relKey;
                TransRelNode2RelKey(rnode, &relKey, (ForkNumber)_forknum);

                RelSizePthreadWriteLock(relKey);
                InsertRelSizeCache(relKey, _blknum);
                RelSizePthreadUnlock(relKey);
                //        printf("%s %d\n", __func__ , __LINE__);
                //        fflush(stdout);
        }

        // Following are fd.c interfaces
        void RpcFileClose(const _File _fd)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                FileClose(_fd);
#ifdef INFO_FUNC_END
                printf("%s end\n", __func__);
#endif
        }

        void RpcTablespaceCreateDbspace(const _Oid _spcnode, const _Oid _dbnode, const bool isRedo)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                TablespaceCreateDbspace(_spcnode, _dbnode, isRedo);
#ifdef INFO_FUNC_END
                printf("%s end\n", __func__);
#endif
        }

        _File RpcPathNameOpenFile(const _Path &_path, const _Flag _flag)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start, filename = %s\n", __func__, _path.c_str());
#endif
                _File result = PathNameOpenFile(_path.c_str(), _flag);
//        printf("[%s] result = %d\n", __func__ , result);
#ifdef INFO_FUNC_END
                printf("%s end\n", __func__);
#endif
                return result;
        }

        // todo
        int32_t RpcFileWrite(const _File _fd, const _Page &_page, const int32_t _amount, const _Off_t _seekpos, const int32_t _wait_event_info)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                // Your implementation goes here
                char buff[BLCKSZ + 8];
                _page.copy(buff, BLCKSZ);
                return FileWrite(_fd, buff, _amount, _seekpos, _wait_event_info);

                //        int writeLen = 0;
                //        char * page = (char *) malloc(BLCKSZ);
                //        _page.copy(page, BLCKSZ);
                //
                //        RpcRelation relNode = ParseRpcRequestPath(FilePathName(_fd), _seekpos);
                //        if (relNode.parseSucc) {
                //            writeLen = RpcFileWriteWithCache(_fd, page, relNode, _seekpos);
                //        } else {
                // We arrived here only when some rare cases occur, for example, have backendID etc.
                //            writeLen = FileWrite(_fd, page, _amount, _seekpos, _wait_event_info);
                //        }
                //
                //        free(page);
                //        return writeLen;
        }

        void RpcFilePathName(_Path &_return, const _File _fd)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                char *filename = FilePathName(_fd);
                _return.assign(filename);
#ifdef INFO_FUNC_END
                printf("%s end\n", __func__);
#endif
                return;
        }

        // todo
        void RpcFileRead(_Page &_return, const _File _fd, const int32_t _amount, const _Off_t _seekpos, const int32_t _wait_event_info)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                char *page = (char *)malloc(BLCKSZ);
                int readLen = 0;

                //        RpcRelation relNode = ParseRpcRequestPath(FilePathName(_fd), _seekpos);
                //        printf("[%s]parse succ=%d, spc = %d, db = %d, rel = %d, fork = %d, block = %d\n",
                //               __func__, relNode.parseSucc, relNode.spcNode, relNode.dbNode, relNode.relNode, relNode.forkNum, relNode.blockNum);
                //        if (relNode.parseSucc) {
                //            readLen = RpcFileReadWithCache(_fd, page, relNode, _seekpos);
                //        } else {
                // We arrived here only when some rare cases occur, for example, have backendID etc.
                readLen = FileRead(_fd, page, _amount, _seekpos, _wait_event_info);
                //        }

                _return.assign(page, readLen);
                free(page);
                return;
        }

        // todo
        int32_t RpcFileTruncate(const _File _fd, const _Off_t _offset)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s :start\n", __func__);
#endif
                return FileTruncate(_fd, _offset, WAIT_EVENT_DATA_FILE_TRUNCATE);
        }

        _Off_t RpcFileSize(const _File _fd)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start, fd = %d, tid = %d\n", __func__, _fd, gettid());
#endif
                _Off_t result = FileSize(_fd);
#ifdef INFO_FUNC_END
                printf("%s end, tid = %d, fd = %d, result = %d\n", __func__, gettid(), _fd, result);
#endif
                return result;
        }

        int32_t RpcFilePrefetch(const _File _fd, const _Off_t _offset, const int32_t _amount, const int32_t wait_event_info)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                return FilePrefetch(_fd, _offset, _amount, wait_event_info);
        }

        void RpcFileWriteback(const _File _fd, const _Off_t _offset, const _Off_t nbytes, const int32_t wait_event_info)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                FileWriteback(_fd, _offset, nbytes, wait_event_info);
                return;
        }

        int32_t RpcUnlink(const _Path &_path)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                return unlink(_path.c_str());
        }

        int32_t RpcFtruncate(const _File _fd, const _Off_t _offset)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                return ftruncate(_fd, _offset);
        }

        void RpcInitFile(_Page &_return, const _Path &_path)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
        }

        _File RpcOpenTransientFile(const _Path &_filename, const int32_t _fileflags)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                return OpenTransientFile(_filename.c_str(), _fileflags);
        }

        int32_t RpcCloseTransientFile(const _File _fd)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                return CloseTransientFile(_fd);
        }

        void Rpcread(_Page &_return, const _File _fd, const int32_t size)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
        }

        int32_t Rpcwrite(const _File _fd, const _Page &_page, const int32_t size)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
        }

        int32_t RpcFileSync(const _File _fd, const int32_t _wait_event_info)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                return FileSync(_fd, _wait_event_info);
        }

        void RpcPgPRead(_Page &_return, const _File _fd, const int32_t _seg_bytes, const _Off_t _start_off)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                char *p = (char *)malloc(_seg_bytes + 64);
                if (_start_off == -1)
                {
                        read(_fd, p, _seg_bytes);
                }
                else
                {
                        pg_pread(_fd, p, _seg_bytes, _start_off);
                }
                _return.assign(p, _seg_bytes);
                free(p);
                return;
        }

        int32_t RpcPgPWrite(const _File _fd, const _Page &_page, const int32_t _amount, const _Off_t _offset)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                int32_t result;
                if (_offset == -1)
                {
                        result = write(_fd, _page.c_str(), _amount);
                }
                else
                {
                        result = pg_pwrite(_fd, _page.c_str(), _amount, _offset);
                }
                //        printf("RpcPgPWrite, result = %d\n", result);
                return result;
        }

        int32_t RpcClose(const _File _fd)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                return close(_fd);
        }

        int32_t RpcBasicOpenFile(const _Path &_path, const int32_t _flags)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
                int32_t result = BasicOpenFile(_path.c_str(), _flags);
#ifdef INFO_FUNC_START
                printf("%s start, fileName = %s, result = %d\n", __func__, _path.c_str(), result);
                fflush(stdout);
#endif
                return result;
        }

        int32_t RpcPgFdatasync(const _File _fd)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                return pg_fdatasync(_fd);
        }

        int32_t RpcPgFsyncNoWritethrough(const _File _fd)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                return pg_fsync_no_writethrough(_fd);
        }

        int32_t RpcLseek(const int32_t _fd, const _Off_t _offset, const int32_t _flag)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                return lseek(_fd, _offset, _flag);
        }

        void RpcStat(_Stat_Resp &_return, const _Path &_path)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                struct stat result;
                _return._result = stat(_path.c_str(), &result);
                _return._stat_mode = result.st_mode;
                return;
        }

        int32_t RpcDirectoryIsEmpty(const _Path &_path)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                return directory_is_empty(_path.c_str());
        }

        int32_t RpcCopyDir(const _Path &_src, const _Path &_dst)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                char *src = (char *)malloc(1024);
                char *dst = (char *)malloc(1024);
                //        printf("_src = %s, dst = %s\n", _src.c_str(), _dst.c_str());
                _src.copy(src, _src.length());
                _dst.copy(dst, _dst.length());
                src[_src.length()] = 0;
                dst[_dst.length()] = 0;
                //        printf("src = %s, dst = %s\n", src, dst);
                copydir(src, dst, false);
                free(src);
                free(dst);
                return 0;
        }

        int32_t RpcPgFsync(const int32_t _fd)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                int32_t result = pg_fsync(_fd);
                //        printf("RpcPgFsync, result = %d\n", result);
                return result;
        }

        int32_t RpcDurableUnlink(const _Path &_fname, const int32_t _flag)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                return durable_unlink(_fname.c_str(), _flag);
        }

        int32_t RpcDurableRenameExcl(const _Path &_oldFname, const _Path &_newFname, const int32_t _elevel)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start, oldName = %s, newName = %s\n", __func__, _oldFname.c_str(), _newFname.c_str());
                fflush(stdout);
#endif
                int32_t result = durable_rename_excl(_oldFname.c_str(), _newFname.c_str(), _elevel);
#ifdef INFO_FUNC_START
                printf("%s end\n", __func__);
                fflush(stdout);
#endif

                return result;
        }

        int32_t RpcXLogWrite(const _File _fd, const _Page &_page, const int32_t _amount, const _Off_t _offset, const std::vector<int64_t> &_xlblocks, const int32_t _blknum, const int32_t _idx, const int64_t _lsn)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                // printf("%s start\n", __func__);
                // printf("%s %d, blockNum = %d, start_idx = %d, lsn = %ld, offset = %ld, amount = %d\n", __func__, __LINE__, _blknum, _idx, _lsn, _offset, _amount);
                // for (int i = 0; i < _blknum; i++)
                // {
                //         printf("_xlblocks[%d] = %ld\n", i, _xlblocks[i]);
                // }
                // fflush(stdout);
                // printf("%s %d, start lsn = %lu, end lsn = %ld\n", __func__, __LINE__, _lsn, _xlblocks[_blknum - 1]);
                // fflush(stdout);
                // Your implementation goes here
#ifdef INFO_FUNC_START
                printf("%s %d, blockNum = %d, start_idx = %d, lsn = %ld\n", __func__, __LINE__, _blknum, _idx, _lsn);
                for (int i = 0; i < _blknum; i++)
                {
                        printf("_xlblocks[%d] = %ld\n", i, _xlblocks[i]);
                }
                fflush(stdout);
                printf("%s %d, start lsn = %lu, end lsn = %ld\n", __func__, __LINE__, _lsn, _xlblocks[_blknum - 1]);
                fflush(stdout);
#endif

                int32_t result = pg_pwrite(_fd, _page.c_str(), _amount, _offset);

#ifdef ENABLE_DEBUG_INFO
                printf("%s %d\n", __func__, __LINE__);
                fflush(stdout);
#endif

                // Need some lock
                for (int i = 0; i < _blknum; i++)
                {
#ifdef ENABLE_DEBUG_INFO
                        printf("%s %d, try to get %d locks\n", __func__, __LINE__, _idx + i);
                        fflush(stdout);
#endif
                        pthread_rwlock_wrlock(&(RpcXLogPagesLocks[(_idx + i)]));
                        RpcXlblocks[(_idx + i) % XLOGbuffers] = _xlblocks[i];
                        // printf("%s %d, set RpcXlblocks[%d] = %ld\n", __func__, __LINE__, (_idx + i) % XLOGbuffers, _xlblocks[i]);
                }

#ifdef ENABLE_DEBUG_INFO
                printf("%s %d\n", __func__, __LINE__);
                fflush(stdout);
#endif


                // Based on XLogWrite code, startIdx+_blknum <= XLogBuffers-1
                // So, RpcXLogPages + (_idx*BLCKSZ) + (_blknum*BLCKSZ) will smaller than or equal with end of RpcXLogPages
                memcpy(RpcXLogPages + (XLOG_BLCKSZ * _idx), _page.c_str(), XLOG_BLCKSZ * _blknum);

#ifdef NeonAsRemoteStorageEngine

                // printf("_amount = %lu, pageOffset = %d, _lsn = %lu\n", _amount, pageOffset, _lsn);
                // fflush(stdout);

                // Before we start sending the new xlogs, we should check whether the Neon cached up with our server
                // if(!NeonCachedUp) {
                //         NeonCachedUp = 1;

                //         int64_t segmentStartLSN = RpcXlblocks[_idx % XLOGbuffers] - RpcXlblocks[_idx % XLOGbuffers] % wal_segment_size;
                //         NeonFlushedLSN = segmentStartLSN + _offset;
                //         if(NeonStartupLSN < NeonFlushedLSN) {
                //                 SyncXLogWithNeonUntilLSN(neon_socket, NeonStartupLSN, NeonFlushedLSN);
                //         } else {
                //                 NeonFlushedLSN = NeonStartupLSN;
                //         }
                // }

                // _page is a pointer, points to the start of the page that xlogWriteStartLSN exists
                // So, the xlogWriteStartLSN need a offset
                int64_t pageOffset = NeonFlushedLSN % XLOG_BLCKSZ;

                // _idx is the start_idx
                // TODO: The 1st lsn is not counted from 0. So the segmentStartLSN is WRONG.
                int64_t xlogWriteEndLSN = _lsn;
                // printf("%s %d, RpcXlblocks[%d] = %lu, xlogWriteStartLSN = %lu, xlogWriteEndLSN = %lu\n",
                //        __func__, __LINE__, _idx % XLOGbuffers, RpcXlblocks[_idx % XLOGbuffers],
                //        NeonFlushedLSN, xlogWriteEndLSN);

                // We received Neon's startup LSN, for the xlog that before the startup LSN, we should ignore them, don't send them to Neon
                // xlogWriteEndLSN -= xlogWriteEndLSN%BLCKSZ;
                if (xlogWriteEndLSN > NeonFlushedLSN)
                {
                        send_xlog_to_neon_engine(neon_socket, NeonFlushedLSN, xlogWriteEndLSN, 0, xlogWriteEndLSN-NeonFlushedLSN, _page.c_str() + pageOffset);
                        printf("Send xlog to Neon, start = %lu, end = %lu\n", NeonFlushedLSN, xlogWriteEndLSN);

                        NeonFlushedLSN = xlogWriteEndLSN;
                        // if (xlogWriteStartLSN >= NeonStartupLSN)
                        // {
                                // for this xlog, we will send xlog _page[pageOffset, end-start] to the neon engine
                                // send_xlog_to_neon_engine(neon_socket, xlogWriteStartLSN, xlogWriteEndLSN, 0, xlogWriteEndLSN-xlogWriteStartLSN, _page.c_str() + pageOffset);
                        // }
                        // else
                        // {
                                // int shouldIgnoreBytes = NeonStartupLSN - xlogWriteStartLSN;
                                // send_xlog_to_neon_engine(neon_socket, NeonStartupLSN, xlogWriteEndLSN, 0, (xlogWriteEndLSN-xlogWriteStartLSN) - shouldIgnoreBytes, _page.c_str() + pageOffset);
                        // }
                }
#endif

                for (int i = 0; i < _blknum; i++)
                {  
                        pthread_rwlock_unlock(&(RpcXLogPagesLocks[(_idx + i)]));
#ifdef ENABLE_DEBUG_INFO
                        printf("%s %d, released %d locks\n", __func__, __LINE__, _idx + i);
                        fflush(stdout);
#endif
                }

#ifdef ENABLE_DEBUG_INFO
                printf("%s %d\n", __func__, __LINE__);
                fflush(stdout);
#endif
                if (RpcXLogFlushedLsn < _lsn)
                {
                        RpcXLogFlushedLsn = (uint64_t)_lsn;
                }
                pthread_mutex_lock(&wakeupMutex);
#ifdef ENABLE_DEBUG_INFO
                printf("%s %d\n", __func__, __LINE__);
                fflush(stdout);
#endif
                //        WakeupRecovery();
                WakeupStartupRecovery();
                pthread_mutex_unlock(&wakeupMutex);
#ifdef ENABLE_DEBUG_INFO
                printf("%s %d\n", __func__, __LINE__);
                fflush(stdout);
#endif

                // sigusr1_handler(SIGNAL_ARGS) -> should send signal to RpcServer
                // how to set flushUpto? set it with _blknum-1 pages? Or XLogWrite also send XLogWriteResult.lsn to this function.

                return result;
        }

        void RpcXLogFileInit(_XLog_Init_File_Resp &_return, const int64_t _logsegno, const int32_t _use_existent, const int32_t _use_lock)
        {
#ifdef ENABLE_FUNCTION_TIMING
                FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
                printf("%s start\n", __func__);
#endif
                //        printf("%s start\n", __func__ );
                //        fflush(stdout);

                bool use_existent = (_use_existent == 1);
                bool use_lock = (_use_lock == 1);

                int fd = XLogFileInit(_logsegno, &use_existent, use_lock);

                _return._fd = fd;
                _return._use_existent = use_existent;
        }

        _File RpcOpenTransientFileUnderPgData(const _Path& _filename, const int32_t _fileflags) {
                // Your implementation goes here
                // printf("RpcOpenTransientFileUnderPgData\n");
                char* pgDataPath = getenv("PGDATA");
                // connect pgDataPath with _filename
                std::string pgDataPathStr(pgDataPath);
                std::string filenameStr(_filename.c_str());
                std::string fullPath = pgDataPathStr + "/" + filenameStr;

                return OpenTransientFile(fullPath.c_str(), _fileflags);
        }

        int32_t RpcBasicOpenFileUnderPgData(const _Path& _path, const int32_t _flags) {
                // Your implementation goes here
                // printf("RpcOpenTransientFileUnderPgData\n");
                char* pgDataPath = getenv("PGDATA");
                // connect pgDataPath with _filename
                std::string pgDataPathStr(pgDataPath);
                std::string filenameStr(_path.c_str());
                std::string fullPath = pgDataPathStr + "/" + filenameStr;

                return BasicOpenFile(fullPath.c_str(), _flags);
        }
        /**
         * This method has a oneway modifier. That means the client only makes
         * a request and does not listen for any response at all. Oneway methods
         * must be void.
         */
        void zip()
        {
                // Your implementation goes here
                printf("zip\n");
        }
};

void RpcServerLoop(void)
{
#ifdef NeonAsRemoteStorageEngine
        printf("RpcServerLoop start\n");
        fflush(stdout);
        neon_socket = start_server(NeonListenPort);
        if (neon_socket > 0)
        {
                printf("Neon Server started on port %d\n", NeonListenPort);
        }

        char* tenant_id = getenv("tenant_id");
        char* timeline_id = getenv("timeline_id");
        printf("tenant_id = %s, timeline_id = %s\n", tenant_id, timeline_id);
        fflush(stdout);


        process_start_replication_cmd(neon_socket);

        char* pgDataPath = getenv("PGDATA");
        bool crcOk = false;
        ControlFileData *controlFileData = get_controlfile(pgDataPath, &crcOk);
        printf("RpcServer got control file's last checkpoint: %lu\n", controlFileData->checkPoint);
        fflush(stdout);
        AuroraStartupLSN = controlFileData->checkPoint;
        pfree(controlFileData);

        // Arise a thread to keep reading from neon_socket
        // This could make flushing xlog to neon is asynchronous
        pthread_t neon_xlog_resp_tid = 0;
        if (pthread_create(&neon_xlog_resp_tid, NULL, process_neon_xlog_resp, NULL) != 0)
        {
                printf("Create neon_xlog_resp thread failed\n");
                fflush(stdout);
        } else {
                printf("Create neon_xlog_resp thread success\n");
                fflush(stdout);
        }


        SyncXLogWithNeonUntilLSN(neon_socket, NeonStartupLSN, AuroraStartupLSN);
        printf("Neon synced with OpenAurora\n");
        if(NeonStartupLSN > AuroraStartupLSN) {
                NeonFlushedLSN = NeonStartupLSN;
        } else {
                NeonFlushedLSN = AuroraStartupLSN;
        }

        // Initialize NeonAccessLock
        for (int i = 0; i < NeonApiSocketNum; i++) {
                pthread_mutex_init(&(NeonAccessLock[i]), NULL);
                printf("NeonAccessLock[%d] initialized\n", i);
                fflush(stdout);

                neon_api_socket[i] = init_neon_api_socket(NeonApiPort, tenant_id, timeline_id);
                printf("Connected with server started on port %d\n", NeonApiPort);
                fflush(stdout);
        }
#endif

        int port = 9092;

        std::shared_ptr<concurrency::ThreadFactory> threadFactory = std::make_shared<concurrency::ThreadFactory>(new concurrency::ThreadFactory());
        //    std::shared_ptr<concurrency::ThreadManager> threadManager = concurrency::ThreadManager::newThreadManager();
        std::shared_ptr<concurrency::ThreadManager> threadManager = concurrency::ThreadManager::newSimpleThreadManager(150);
        threadManager->threadFactory(threadFactory);
        threadManager->start();

        //    TSimpleServer server(
        //    TThreadedServer server(
        std::shared_ptr<server::TServer> server;
        server.reset(new TThreadPoolServer(
            std::make_shared<DataPageAccessProcessor>(std::make_shared<DataPageAccessHandler>()),
            std::make_shared<TServerSocket>(port), // port
            std::make_shared<TBufferedTransportFactory>(),
            std::make_shared<TBinaryProtocolFactory>(),
            threadManager));

        concurrency::ThreadFactory factory;
        factory.setDetached(false);
        std::shared_ptr<apache::thrift::concurrency::Runnable> serverThreadRunner(server);
        std::shared_ptr<apache::thrift::concurrency::Thread> thread = factory.newThread(serverThreadRunner);
        thread->start();
        concurrency::Monitor gMonitor;
        gMonitor.waitForever();

        server->stop();
        thread->join();
        server.reset();
}
